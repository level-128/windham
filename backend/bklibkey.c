//
// Created by level-128 on 1/19/24.
//

#pragma once

#include <errno.h>
#include <huffman.h>
#include <sha256.h>
#include <float.h>
#include <wchar.h>
#include "bksrclib.c"
#include <windham_const.h>

#define MIN_KEY_CHAR 7


typedef struct {
   char *   key_or_keyfile_location;
   uint32_t key_type;
} Key;


enum {
  NMOBJ_key_file_type_input, // ask key
  NMOBJ_key_file_type_input_systemd, // ask key through systemd
  NMOBJ_key_file_type_input_stdin, // key from stdin
  NMOBJ_key_file_type_key, // using --key
  NMOBJ_key_file_type_file, // keyfile
  NMOBJ_key_file_type_masterkey, // --master-key=
  NMOBJ_key_file_type_key_raw, // random key generated by windham
};


#define MAX_PASSWORD_INPUT_LEN 256


uint8_t hex_char_to_int(char ch) {
   if (ch == 0) {
      print_error(_("error when parsing key: invalid length"));
   }
   if ('0' <= ch && ch <= '9') {
      return ch - '0';
   }
   if ('a' <= ch && ch <= 'f') {
      return ch - 'a' + 10;
   }
   print_error(_("error when parsing key: invalid character; only hexadecimal is accepted."));
   return -1;
}


bool master_key_to_byte_array(const char * hex_string, uint8_t byte_array[HASHLEN]) {
   int str_index = 0, byte_index = 0;
   while (byte_index != HASHLEN) {
      while (hex_string[str_index] == ' ' || hex_string[str_index] == '-' || hex_string[str_index] == '\n') {
         ++str_index;
      }

      int high_nibble = hex_char_to_int(hex_string[str_index]);
      ++str_index;
      while (hex_string[str_index] == ' ' || hex_string[str_index] == '-' || hex_string[str_index] == '\n') {
         ++str_index;
      }

      int low_nibble = hex_char_to_int(hex_string[str_index]);

      byte_array[byte_index] = (high_nibble << 4) + low_nibble;
      str_index ++;
      ++byte_index;
   }
   while (hex_string[str_index] == ' ' || hex_string[str_index] == '-' || hex_string[str_index] == '\n') {
      ++str_index;
   }
   if (hex_string[str_index] != 0) {
      return false;
   }
   return true;
}

int wcwidth(wchar_t c);

int get_char_display_width(const char * mbchar) {
   wchar_t wch;

   int len = mbtowc(&wch, mbchar, MB_CUR_MAX);
   if (len <= 0) {
      return 0; // Invalid multibyte character or conversion error
   }

   // Get the display width of the wide character
   int width = wcwidth(wch);
   if (width < 0) {
      return 0; // Non-printable character
   }

   return width;
}

void get_password_input(char input[MAX_PASSWORD_INPUT_LEN]) {
#ifdef IS_FRONTEND_ENTRY
  struct termios raw = oldt;
  raw.c_lflag &= ~(ICANON | ECHO);
  tcsetattr(STDIN_FILENO, TCSANOW, &raw);
#endif
  bool is_echo = false;

   for (unsigned index = 0; index < MAX_PASSWORD_INPUT_LEN - 1; index ++) {
      char ch = getchar();
      if (ch == '\n') {
         if (index == 0) {
            print_error(_("Empty imput. Password required."));
         }
         input[index] = '\00';
         goto END;
      }
      if (ch == '\t') {
         char * msg = _("Tab pressed. press again to echo.");
         printf("%s", msg);
         fflush(stdout);
         ch = getchar();

         printf("\r");
         for (unsigned i = 0; i < strlen(msg); i ++) {
            printf(" ");
         }
         printf("\r");
         fflush(stdout);
         if (ch == '\t') {
            input[index] = '\x00';
            printf("%s", input);
            fflush(stdout);
            is_echo = true;
            index -= 1;
            continue;
         }
      }
      if (ch == '\x7f') {
         if (index == 0) {
            putchar(7);
            index -= 1;
            continue;
         }
         // multibyte
         int i = 0;
         for (; index - i != 0 && input[index - i - 1] >= '\x80' && input[index - i - 1] <= '\xbf'; i ++);
         i += 1;
         index -= i;

         for (int j = get_char_display_width(input + index); is_echo && j > 0; j --) {
            printf("\b \b");
         }
         input[index] = 0;
         index --;
         continue;
      }
      if (is_echo) {
         putchar(ch);
      }
      input[index] = ch;
   }
   print_warning(
      _("The max password input size is %i bytes. No new input will be accepted. Consider key file instead."
      ),
      MAX_PASSWORD_INPUT_LEN - 1);
   printf(_("press enter to proceed."));
   while (getchar() != '\n') { }
   input[MAX_PASSWORD_INPUT_LEN - 1] = '\00';

END:
   #ifdef IS_FRONTEND_ENTRY

   tcsetattr(STDIN_FILENO, TCSANOW, &oldt);
   #endif
   if (strcmp(input, "level-128") == 0) {
      print_error("ðŸ‘¿");
   }
}


void get_key_input_from_the_console(const char * device, char password[MAX_PASSWORD_INPUT_LEN], const bool is_new_key) {
   char password2[MAX_PASSWORD_INPUT_LEN];
   printf(_("Password for %s:\n"), device);
   get_password_input(password);
   printf(_("\nConfirm password:\n"));
   get_password_input(password2);
   if (strcmp(password, password2) != 0) {
      print_error(_("Passwords do not match."));
   } else if (strlen(password) < MIN_KEY_CHAR && is_new_key) {
      print_error(
         _("the provided password is too short (%zu characters), which is not recommended. To bypass this restriction, use "
            "argument --key instead."),
         strlen(password));
   }
}


void get_key_input_from_the_console_systemd(const char * device, char password[MAX_PASSWORD_INPUT_LEN]) {
   int    exec_ret_val;
   char * dup_stdout = NULL;
   char * exec_dir[] = {"/bin", "/usr/bin", "/sbin", "/usr/sbin", NULL};
   size_t dup_stdout_len;
   char   password_prompt[strlen("password for ") + strlen(device) + strlen(":") + 1];
   sprintf(password_prompt, "password for %s:", device);

   if (exec_name(
          "systemd-ask-password",
          exec_dir,
          -1,
          &dup_stdout,
          &dup_stdout_len,
          &exec_ret_val,
          NMOBJ_exec_name_wait_child,
          password_prompt,
          NULL) == false) {
      if (errno == ENOENT) {
         print_error(
            _(
               "\"systemd-ask-password\" is not available. Param \"--systemd-dialog\" only supports system with systemd as init."
            ));
      } else {
         print_error(_("failed to call \"systemd-ask-password\"."));
      }
   } else if (exec_ret_val != 0) {
      print_error(_("Cannot get password from systemd service"));
   }
   dup_stdout[dup_stdout_len - 1] = '\x00';
   strncpy(password, dup_stdout, MAX_PASSWORD_INPUT_LEN);
   free(dup_stdout);
}


void read_key_file(const Key key, uint8_t inited_key[HASHLEN]) {
   char *     filename = key.key_or_keyfile_location;
   uint8_t *  buffer[1024];
   SHA256_CTX sha_256_ctx;
   size_t     bytes_read;

   int file = open(filename, O_RDONLY);
   if (file < 0) {
      print_error(_("Cannot open keyfile %s. Reason: %s"), filename, strerror(errno));
   }

   sha256_init(&sha_256_ctx);

   while ((bytes_read = read(file, buffer, 1024)) > 0) {
      sha256_update(&sha_256_ctx, buffer, bytes_read);
   }
   sha256_final(&sha_256_ctx, inited_key);
   close(file);
}


void read_key_stdin(uint8_t inited_key[HASHLEN]) {
   char buffer[1024];

   int fd = open("/dev/stdin", O_RDONLY);
   if (fd == -1) {
      perror("open");
      windham_exit(1);
   }

   ssize_t bytes_read = read(fd, buffer, sizeof(buffer) - 1);
   if (bytes_read == -1) {
      perror("read");
      windham_exit(1);
   }
   if (bytes_read == sizeof(buffer)) {
      print_error(_("input is too long!"));
   }
   buffer[bytes_read] = '\0';
   close(fd);
   if (master_key_to_byte_array(buffer, inited_key) == false) {
      print_error(_("error when parsing key: invalid length"));
   };
}


bool prepare_key(const Key key, uint8_t inited_key[HASHLEN], const char * device) {
   size_t key_size = 0;
   char   password[MAX_PASSWORD_INPUT_LEN];

   switch (key.key_type) {
   case NMOBJ_key_file_type_masterkey:
      return false;
   case NMOBJ_key_file_type_input:
      get_key_input_from_the_console(device, password, true);
      key_size = strlen(password);
      sha256_digest_all(password, key_size, inited_key);
      break;
   case NMOBJ_key_file_type_input_systemd:
      get_key_input_from_the_console_systemd(device, password);
      key_size = strlen(password);
      sha256_digest_all(password, key_size, inited_key);
      break;
   case NMOBJ_key_file_type_file:
      read_key_file(key, inited_key);
      return true;
   case NMOBJ_key_file_type_key:
      key_size = strlen(key.key_or_keyfile_location);
      sha256_digest_all(key.key_or_keyfile_location, key_size, inited_key);
      break;
   case NMOBJ_key_file_type_input_stdin:
      read_key_stdin(inited_key);
      return true; // the key has high entropy
   case NMOBJ_key_file_type_key_raw:
      memcpy(inited_key, key.key_or_keyfile_location, HASHLEN);
      return true;
   default:
      __builtin_trap();
   }
   const bool result = get_is_high_entropy(key_size, (uint8_t *) password);
   return result;
}


char * interactive_ask_new_key_test_key = NULL;


void action_addkey_interactive_prepare_key(Key * new_key) {
   int option = 1;
   if (interactive_ask_new_key_test_key == NULL) {
      option = ask_option("Add a new key: choose your key format.", "input key from console", "use a key file", NULL);
   }
   if (option == 1) {
      if (interactive_ask_new_key_test_key == NULL) {
         new_key->key_type                = NMOBJ_key_file_type_input;
         new_key->key_or_keyfile_location = NULL;
      } else {
         new_key->key_type                = NMOBJ_key_file_type_key;
         new_key->key_or_keyfile_location = interactive_ask_new_key_test_key;
         interactive_ask_new_key_test_key = NULL;
      }
   } else if (option == 2) {
      char * file_location = NULL;
      size_t n             = 0;
      printf("Key file location:");
      ssize_t len = getline(&file_location, &n, stdin);
      if (len == -1) {
         print_error(_("input error; %s"), strerror(errno));
      } else if (len < 2) {
         print_error(_("empty keyfile input."));
      }
      if (file_location[len - 1] == '\n') {
         file_location[len - 1] = '\x00';
      }
      new_key->key_or_keyfile_location = file_location;
      new_key->key_type                = NMOBJ_key_file_type_file;
   }
}


void get_master_key(
   Data         self,
   uint8_t      master_key[HASHLEN],
   const Key    key,
   const char * device,
   uint64_t     max_unlock_mem,
   double       max_unlock_time,
   int          max_unlock_level,
   const bool   is_allow_nolock,
   int * ret_level,
   int * ret_key_zone,
   uint16_t * ret_key_location) {
   if (key.key_type == NMOBJ_key_file_type_masterkey) { // do nothing
     if (check_master_key_check(self, master_key) == false){
       print_error(_("Wrong master key."));
     }
     return;
   }
   uint8_t inited_key[HASHLEN];
   prepare_key(key, inited_key, device);

   *ret_key_location = get_keypool_location_candidate(self.master_key_mask, inited_key);

   max_unlock_mem = check_target_mem(max_unlock_mem, false, is_allow_nolock);

   Key_slot keyslots[2];
   memcpy(&keyslots[0], &self.keypool[0].keypool[*ret_key_location], sizeof(Key_slot));
   memcpy(&keyslots[1], &self.keypool[1].keypool[*ret_key_location], sizeof(Key_slot));

   int unlocked_slot = read_key_from_data(
      self,
      inited_key,
      *ret_key_location,
      max_unlock_time,
      max_unlock_mem,
      max_unlock_level,
      is_allow_nolock,
      ret_key_zone,
      ret_level,
      master_key);

   //TODO: add all error outputs
   if (unlocked_slot == NMOBJ_Enclib_calc_failed_reached_max_mem) {
      print_error(
         _("Cannot unlock the target probably due to incorrect key.\n"
            "\tIf you are certain that the key is indeed correct, because the memory limit has reached, try increasing the maximum "
            "memory limit "
            "using --max-unlock-memory."));
   } else if (unlocked_slot == NMOBJ_Enclib_alloc_failed_no_free_mem) {
      print_error(
         _("Cannot unlock the target because of insufficient system memory.\n"
            "\tIf you are certain that the key is indeed correct, try consider exporting the master key on a more "
            "computationally powerful device and then use the master key to unlock the target."
         ));
   } else if (unlocked_slot == NMOBJ_Enclib_calc_failed_no_time) {
      print_error(
         _("Cannot unlock the target probably due to incorrect key.\n"
            "\tIf you are certain that the key is indeed correct, because the time limit has reached, try increasing the maximum "
            "time limit "
            "using --max-unlock-time."));
   }
}


void print_msg_for_generate_key_slot(
   int      return_val,
   uint64_t target_mem) {
   switch (return_val) {
   case NMOBJ_Enclib_alloc_failed_no_free_mem:
      if (target_mem) {
         print_warning(_("Designated memory constrains cannot be reached due to insufficient system ram."));
      } else {
         print_warning(_("The system has no enough free ram to met its security target. "));
      }
      break;
   case NMOBJ_Enclib_alloc_failed_policy_nolock:
      print_warning(_("Designated memory constrains cannot be reached due to insufficient system ram."));
      break;
   case NMOBJ_Enclib_alloc_failed_lock_error:
      print_error(_("Failed to lock memory: hitting resource limit (RLIMIT_MEMLOCK) or missing CAP_IPC_LOCK permission."));
      break;
   default: ;
   }
}

void add_key_to_keyslot(
   Data *        decrypted_self,
   const uint8_t master_key[HASHLEN],
   const Key     key_key,
   const char *  device,
   uint64_t      target_mem,
   const double  target_time,
   const int     target_level,
   const bool    is_no_detect_entropy,
   const bool    rapid_add,
   const bool    is_anonymous_key,
   const bool    is_allow_nolock,
   int *         ret_target_level) {
#define SET_BIT(n, x, y) ((n & ~(1U << (x))) | ((y & 1) << (x)))

   uint8_t inited_key[HASHLEN];

   int free_slot;
   // check slot availability
   for (int i = 0; i < KEY_SLOT_COUNT; i ++) {
      if (decrypted_self->metadata.keyslot_level[i] == 0) {
         free_slot = i;
         goto END_LOOP;
      }
   }
   print_error(_("No free slot available. Remove a password or keyfile to free a slot."));
 END_LOOP:;

   // prepare key and detect is already used
   const bool is_high_entropy_key = prepare_key(key_key, inited_key, device);
   if (is_high_entropy_key) {
      if (key_key.key_type == NMOBJ_key_file_type_file) {
         printf(
            _(
               "Using a key file allows you to add keys to key slots with decreased cost to increase unlock speed. "
               "to disable this feature, use \"--no-detect-entropy\"\n"));
      } else if (key_key.key_type != NMOBJ_key_file_type_input_stdin && key_key.key_type !=
                 NMOBJ_key_file_type_key_raw) {
         // EMOBJ_key_file_type_input_stdin has is_high_entropy_key attribute true
         printf(
            _(
               "High entropy key detected, adding the key to the keyslot with decreased cost to increase unlock "
               "speed. to disable this feature, use \"--no-detect-entropy\"\n"));
      }
   }

   for (int i = 0; i < KEY_SLOT_COUNT; i ++) {
      if (memcmp(decrypted_self->metadata.keyslot_key[i], inited_key, HASHLEN) == 0) {
         print_error(_("The given key is used at slot %i"), i);
      }
   }

   // get new key mem and time
   if (is_high_entropy_key && ! is_no_detect_entropy) {
      target_mem = 0;
   } else if (target_level != KEY_SLOT_EXP_MAX) {
      // target_level will overwrite everything. in this case, target_mem does not count
      target_mem = check_target_mem(target_mem, true, is_allow_nolock);
   }


   if (rapid_add) {
      Key_slot key_slot;
      int      keyslot_level;

      fill_secure_random_bits((uint8_t *) &key_slot, sizeof(key_slot));

      int return_val = generate_key_slot_key_mask(
         *decrypted_self,
         inited_key,
         master_key,
         target_time,
         target_mem,
         target_level,
         is_allow_nolock,
         &keyslot_level,
         &key_slot);
      print_msg_for_generate_key_slot(return_val, target_mem);

      uint16_t keypool_location_candidate = get_keypool_location_candidate(decrypted_self->master_key_mask, inited_key);
      int      index                      = get_possible_key_location_in_keypool(
         decrypted_self->metadata,
         keypool_location_candidate,
         keyslot_level);
      if (index == -1) {
         print_error(
            _(
               "Rapid Add cannot locate a free area within keypool that could satisfies all constrains. This might happen with a very low "
               "probability, because Rapid Add does not guarantee to add a new password (as it does so incrementally), especially if the partition already has a "
               "lot of passwords registered. Please omit --rapid-add or select a new password if possible."));
      }

      // place key_slot to keypool
      memcpy(
         &decrypted_self->keypool[index].keypool[keypool_location_candidate],
         &key_slot,
         convert_stage_to_size(keyslot_level));
      if (is_anonymous_key == false) {
         memcpy(decrypted_self->metadata.keyslot_key[free_slot], inited_key, HASHLEN);
      }
      decrypted_self->metadata.keyslot_location_area = SET_BIT(
         decrypted_self->metadata.keyslot_location_area,
         free_slot,
         index);
      decrypted_self->metadata.keyslot_level[free_slot]    = keyslot_level;
      decrypted_self->metadata.keyslot_location[free_slot] = keypool_location_candidate;

      *ret_target_level = keyslot_level;
   } else {
      Key_slot key_slots[KEY_SLOT_COUNT];
      uint8_t  keyslot_levels[KEY_SLOT_COUNT];

      memcpy(keyslot_levels, decrypted_self->metadata.keyslot_level, KEY_SLOT_COUNT);

      for (int i = 0; i < KEY_SLOT_COUNT; i ++) {
         if (keyslot_levels[i] != 0 && memcmp(
                decrypted_self->metadata.keyslot_key[i],
                (uint8_t[HASHLEN]){0},
                HASHLEN) == 0) {
            ask_for_conformation(
               _(
                  "Anonymous key registered at slot %i. Non rapid add does not support transforming anonymous key, thus "
		  "this key will be dropped and invalidated. Proceed?"),
               i);
            keyslot_levels[i] = 0;
         }
      }

      fill_secure_random_bits(decrypted_self->master_key_mask, HASHLEN);
      fill_secure_random_bits((uint8_t *) key_slots, sizeof(key_slots));
      // fill all slots to hide side channel information.

      // calcluate new key
      int keyslot_level;
      int return_val = generate_key_slot_key_mask(
         *decrypted_self,
         inited_key,
         master_key,
         target_time,
         target_mem,
         target_level,
         is_allow_nolock,
         &keyslot_level,
         &key_slots[free_slot]);
      print_msg_for_generate_key_slot(return_val, target_mem);

      keyslot_levels[free_slot] = keyslot_level;
      memcpy(decrypted_self->metadata.keyslot_key[free_slot], inited_key, HASHLEN);
      *ret_target_level = keyslot_level;

      bool is_failed_attempt = false;

   GET_RANDOM_LOC_FAILED:
      if (is_failed_attempt) {
         fill_secure_random_bits(decrypted_self->master_key_mask, HASHLEN);
         fill_secure_random_bits((uint8_t *)key_slots, sizeof(key_slots));
         // fill all slots to hide side channel information.
      }
      memset(decrypted_self->metadata.keyslot_level, 0, sizeof(decrypted_self->metadata.keyslot_level));
      memset(decrypted_self->metadata.keyslot_location, 0, sizeof(decrypted_self->metadata.keyslot_location));


      // find possible slot displacement
      for (int i = 0; i < KEY_SLOT_COUNT; i ++) {
         if (keyslot_levels[i] != 0) {
            decrypted_self->metadata.keyslot_location[i] = get_keypool_location_candidate(
               decrypted_self->
               master_key_mask,
               decrypted_self->metadata.
                               keyslot_key[i]);
            int index = get_possible_key_location_in_keypool(
               decrypted_self->metadata,
               decrypted_self->metadata.keyslot_location[i],
               keyslot_levels[i]);
            if (index == -1) {
               is_failed_attempt = true;
               goto GET_RANDOM_LOC_FAILED;
            } else {
               decrypted_self->metadata.keyslot_level[i]      = keyslot_levels[i];
               decrypted_self->metadata.keyslot_location_area = SET_BIT(
                  decrypted_self->metadata.keyslot_location_area,
                  i,
                  index);
            }
         }
      }

      // calculate all old keys. if failed attempt occurs, then calculate new keys within this loop.
      int  keyslot_level_loop;
      bool is_level_okey = true;
      for (int i = 0; i < KEY_SLOT_COUNT; i ++) {
         if (i != free_slot || is_failed_attempt) {
            if (keyslot_levels[i] != 0) {
               return_val = generate_key_slot_key_mask(
                  *decrypted_self,
                  decrypted_self->metadata.keyslot_key[i],
                  master_key,
                  DBL_MAX,
                  SIZE_MAX,
                  keyslot_levels[i],
                  is_allow_nolock,
                  &keyslot_level_loop,
                  &key_slots[i]);
               if (return_val != NMOBJ_Enclib_gen_okay_level_reached) {
                  is_level_okey = false;
                  print_warning(
                     _("Cannot met target strength for key %i, target iteration level: %"PRIu16", iteration done: %i"),
                     i,
                     keyslot_levels[i],
                     keyslot_level_loop);
                  keyslot_levels[i] = keyslot_level_loop;
               }
            }
         }
      }
      if (! is_level_okey) {
         ask_for_conformation(
            _(
               "when transforming passwords, some of them cannot reach their original iteration level. "
	       "A powerful device, which is able to perform more key iterations, will provides enhanced protection against weak passwords. "
	       "This warning is probably because the local"
               " machine has much less memory than the device which add those passwords, or Windham is not "
               "configured to utilise swap space and memory is currently in scarce. Are you willing to proceed?"));
      }
      set_master_key_check(decrypted_self, master_key);

      for (int i = 0; i < KEY_SLOT_COUNT; i ++) {
         if (keyslot_levels[i] != 0) {
            memcpy(
               &decrypted_self->keypool[
                  GET_BIT(decrypted_self->metadata.keyslot_location_area, i)
               ].keypool[
                  decrypted_self->metadata.keyslot_location[i]
               ],
               &key_slots[i],
               convert_stage_to_size(keyslot_levels[i]));
         }
      }
   }
}
